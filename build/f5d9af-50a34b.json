{"block":{"height":700,"license":"MIT"},"readme":"<p>Playground made to explore <a href=\"https://github.com/d3/d3-geo\">d3-geo</a>&#39;s map\n<a href=\"https://github.com/d3/d3-geo#projection_fitExtent\">fit</a> and\n<a href=\"https://github.com/d3/d3-geo#projection_clipExtent\">clip</a> capabilities.</p>\n<h3 id=\"usage\">Usage</h3>\n<p>Start playground with:</p>\n<pre><code>npm start</code></pre>\n<p>Made with <a href=\"https://github.com/freeman-lab/control-panel\"><code>control-panel</code></a>.</p>\n","files":[{"filename":"index.js","body":"var d3 = Object.assign({},\n  require('d3-selection'),\n  require('d3-request'),\n  require('d3-geo'),\n  require('d3-geo-projection')\n)\n\nvar topojson = require('topojson-client')\nvar control = require('control-panel')\n\nvar sphere = {type: 'Sphere'}\nvar baseMapUrl = 'https://d3js.org/world-110m.v1.json'\nvar blk = '#000000'\nvar red = '#990000'\n\nvar panelInputs = [{\n  type: 'range',\n  label: 'Width',\n  min: 0,\n  max: 0.8 * window.innerWidth - 20,\n  initial: 0.8 * window.innerWidth - 20\n}, {\n  type: 'range',\n  label: 'Height',\n  min: 0,\n  max: window.innerHeight - 20,\n  initial: 0.75 * window.innerHeight\n}, {\n  type: 'range',\n  label: 'Pad X',\n  min: 0,\n  max: 0.5 * window.innerWidth,\n  initial: 10\n}, {\n  type: 'range',\n  label: 'Pad Y',\n  min: 0,\n  max: 0.5 * window.innerHeight,\n  initial: 30\n}, {\n  type: 'select',\n  label: 'Projection',\n  options: Object.keys(d3).filter(k => {\n    try {\n      var proj = d3[k]()\n      return proj.invert && proj.stream\n    } catch (e) {\n      return false\n    }\n  })\n  .map(k => k.substr(3)),\n  initial: 'Equirectangular'\n}, {\n  type: 'range',\n  label: 'Yaw',\n  min: -360,\n  max: 360,\n  initial: -180\n}, {\n  type: 'range',\n  label: 'Pitch',\n  min: -180,\n  max: 180,\n  initial: 0\n}, {\n  type: 'range',\n  label: 'Latitude 0',\n  min: -90,\n  max: 90,\n  initial: -60\n}, {\n  type: 'range',\n  label: 'Latitude 1',\n  min: -90,\n  max: 90,\n  initial: 60\n}, {\n  type: 'range',\n  label: 'Longitude 0',\n  min: -180,\n  max: 180,\n  initial: 140\n}, {\n  type: 'range',\n  label: 'Longitude 1',\n  min: -180,\n  max: 180,\n  initial: -140\n}, {\n  type: 'checkbox',\n  label: 'Fit',\n  initial: false\n}, {\n  type: 'checkbox',\n  label: 'Clip',\n  initial: false\n}, {\n  type: 'color',\n  label: 'Canvas color',\n  initial: blk\n}, {\n  type: 'color',\n  label: 'Frame color',\n  initial: blk\n}, {\n  type: 'color',\n  label: 'Sphere color',\n  initial: blk\n}, {\n  type: 'color',\n  label: 'Range box color',\n  initial: red\n}]\n\nvar opts0 = {}\npanelInputs.forEach(o => { opts0[o.label] = o.initial })\n\nvar panel = control(panelInputs, {\n  root: d3.select('body').append('div').node(),\n  theme: 'light',\n  width: '20%'\n})\n\nvar map = {}\nmap.canvas = setCanvas(map, opts0)\nmap.projection = setProjection(map, opts0)\nmap.rangeBox = makeRangeBox(map, opts0)\n\nd3.json(baseMapUrl, (err, topology) => {\n  if (err) throw err\n\n  var baseMap = topojson.mesh(topology)\n\n  var update = (opts) => {\n    map.canvas = setCanvas(map, opts)\n    map.projection = setProjection(map, opts)\n    map.rangeBox = makeRangeBox(map, opts)\n\n    map.context.clearRect(0, 0, opts.Width, opts.Height)\n\n    drawPath(map, baseMap, {\n      lineWidth: 1,\n      strokeStyle: blk\n    })\n    drawPath(map, sphere, {\n      lineWidth: 2.5,\n      strokeStyle: opts['Sphere color']\n    })\n    drawPath(map, map.rangeBox, {\n      lineWidth: 3,\n      strokeStyle: opts['Range box color'],\n      setLineDash: [5]\n    })\n    drawPadRect(map, opts)\n  }\n\n  panel.on('input', update)\n  update(opts0)\n})\n\nfunction _draw (context, fn, style) {\n  context.save()\n  context.beginPath()\n\n  Object.keys(style).forEach(k => {\n    if (typeof context[k] === 'function') {\n      context[k](style[k])\n    } else {\n      context[k] = style[k]\n    }\n  })\n\n  fn()\n  context.closePath()\n  context.stroke()\n  context.restore()\n}\n\nfunction drawPath (map, d, style) {\n  var projection = map.projection\n  var context = map.context\n  var path = d3.geoPath(projection, context)\n  var fn = () => path(d)\n\n  _draw(context, fn, style)\n}\n\nfunction drawPadRect (map, opts) {\n  var context = map.context\n  var w = opts.Width\n  var h = opts.Height\n  var padX = opts['Pad X']\n  var padY = opts['Pad Y']\n  var fn = () => context.rect(padX, padY, w - 2 * padX, h - 2 * padY)\n\n  _draw(context, fn, {\n    lineWidth: 3,\n    strokeStyle: opts['Frame color'],\n    setLineDash: [5]\n  })\n}\n\nfunction setCanvas (map, opts) {\n  if (!map.canvas) {\n    map.canvas = d3.select('body').append('canvas')\n      .style('position', 'absolute')\n      .style('top', '0px')\n      .style('left', '20%')\n  }\n\n  if (!map.context) {\n    map.context = map.canvas.node().getContext('2d')\n  }\n\n  map.canvas\n    .attr('width', opts0.Width)\n    .attr('height', opts0.Height)\n    .style('border', `5px solid ${opts['Canvas color']}`)\n\n  return map.canvas\n}\n\nfunction setProjection (map, opts) {\n  var w = opts.Width\n  var h = opts.Height\n  var padX = opts['Pad X']\n  var padY = opts['Pad Y']\n\n  var extent = [[padX, padY], [w - padX, h - padY]]\n  var proj = d3['geo' + opts.Projection]()\n\n  var apply = (fname, args) => {\n    if (typeof proj[fname] === 'function') {\n      proj = proj[fname].apply(null, args)\n    }\n    return proj\n  }\n\n  apply('rotate', [[opts.Yaw, opts.Pitch]])\n  apply('fitExtent', [extent, opts.Fit ? map.rangeBox : sphere])\n  apply('clipExtent', [opts.Clip ? d3.geoPath(proj).bounds(map.rangeBox) : null])\n\n  return proj\n}\n\nfunction makeRangeBox (map, opts) {\n  var lon0 = opts['Longitude 0']\n  var lon1 = opts['Longitude 1']\n  var lat0 = opts['Latitude 0']\n  var lat1 = opts['Latitude 1']\n\n  // to cross antimeridian w/o ambiguity\n  if (lon0 > 0 && lon1 < 0) {\n    lon1 += 360\n  }\n\n  // to make lat span unambiguous\n  if (lat0 > lat1) {\n    var tmp = lat0\n    lat0 = lat1\n    lat1 = tmp\n  }\n\n  var dlon4 = (lon1 - lon0) / 4\n\n  return {\n    type: 'Polygon',\n    coordinates: [[\n      [lon0, lat0],\n      [lon0, lat1],\n      [lon0 + dlon4, lat1],\n      [lon0 + 2 * dlon4, lat1],\n      [lon0 + 3 * dlon4, lat1],\n      [lon1, lat1],\n      [lon1, lat0],\n      [lon1 - dlon4, lat0],\n      [lon1 - 2 * dlon4, lat0],\n      [lon1 - 3 * dlon4, lat0],\n      [lon0, lat0]\n    ]]\n  }\n}\n"},{"filename":"package.json","body":"{\n  \"name\": \"d3-geo-clip-fit-playground\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Playground made to explore d3-geo's map fit and clip capabilities\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"budo index.js --open --live\",\n    \"build\": \"browserify -t es2020 index.js | uglifyjs | indexhtmlify > index.html\"\n  },\n  \"keywords\": [],\n  \"author\": \"Étienne Tétreault-Pinard <etienne.t.pinard@gmail.com>\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"control-panel\": \"^1.2.0\",\n    \"d3-geo\": \"^1.7.1\",\n    \"d3-geo-projection\": \"^2.3.1\",\n    \"d3-request\": \"^1.0.6\",\n    \"d3-selection\": \"^1.1.0\",\n    \"topojson-client\": \"^3.0.0\"\n  },\n  \"devDependencies\": {\n    \"budo\": \"^10.0.4\",\n    \"es2020\": \"^1.1.9\",\n    \"indexhtmlify\": \"^1.3.1\"\n  }\n}\n"},{"filename":".gitignore","body":"node_modules\nnpm-debug.log*\n"}]}