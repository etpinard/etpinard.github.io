{"block":{"height":600,"license":"MIT"},"readme":"<p>Data taken from NOAA&#39;s NCEP reanalysis products available at:</p>\n<ul>\n<li><a href=\"http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.surface.html\">http://www.esrl.noaa.gov/psd/data/gridded/data.ncep.reanalysis.surface.html</a></li>\n</ul>\n<p>and using this download URL:</p>\n<ul>\n<li><a href=\"ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis.derived/surface/air.mon.mean.nc\">ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis.derived/surface/air.mon.mean.nc</a></li>\n</ul>\n<p>Note that the baseline climate is computed using 1986-2015 data from the same\nreanalysis product. In addition, the displayed surface temperature anomaly\nfields were smoothed in longitude and latitude using a boxcar filter.</p>\n<h3 id=\"libraries-used\">Libraries used</h3>\n<ul>\n<li><p><a href=\"https://github.com/meggart/NetCDF.jl\">NetCDF.jl</a> to pre-process the NetCDF\ndata into surface temperature anomalies JSON outputs.</p>\n</li>\n<li><p>d3 v4 in particular <a href=\"https://github.com/d3/d3-geo\">d3-geo</a> to draw the map\nin Canvas2D and <a href=\"https://github.com/d3/d3-geo-projection\">d3-geo-projection</a>\nto use the <a href=\"https://github.com/d3/d3-geo-projection#geoWinkel3\">Winkel\ntriplets</a> projection.</p>\n</li>\n<li><p><a href=\"https://github.com/mikolalysenko/surface-nets\">surface-nets</a> to compute the\ncontours levels.</p>\n</li>\n</ul>\n<h3 id=\"usage\">Usage</h3>\n<p>Install JavaScript and Julia dependencies:</p>\n<pre><code>make deps\n</code></pre>\n<p>Make HTML page (along with all its required built files):</p>\n<pre><code>make index.html\n</code></pre>\n","files":[{"filename":"index.js","body":"var d3_selection = require('d3-selection')\nvar d3_request = require('d3-request')\nvar d3_zoom = require('d3-zoom')\nvar d3_geo = require('d3-geo')\nvar geoWinkel3 = require('./projection').geoWinkel3\nvar topojson = require('topojson-client')\nvar ndarray = require('ndarray')\nvar surfaceNets = require('surface-nets')\n\nvar data = require('./data.json')\nvar sphere = { type: 'Sphere' }\nvar baseMapUrl = 'https://d3js.org/world-110m.v1.json'\nvar blk = '#000000'\n\nvar map = {\n  width: window.innerWidth,\n  height: window.innerHeight,\n  pad: [30, 100],\n  tickFontSize: [16, 24],\n\n  months: makeMonths(),\n\n  // colorbrewer RdBu-11\n  levels: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],\n  colors: [\n    '#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7',\n    '#f7f7f7',\n    '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'\n  ].reverse(),\n\n  // don't forget to add 2 longitudes as in preprocess.jl\n  lon: {\n    start: data.lon[0],\n    step: data.lon[1],\n    size: data.lon[2] + 2\n  },\n\n  lat: {\n    start: data.lat[0],\n    step: data.lat[1],\n    size: data.lat[2]\n  },\n\n  // show last month in first view\n  ind: data.z.length - 1,\n\n  contours: null,\n  array: null\n}\n\nmap.dropdown = drawDropdown(map)\n\nmap.colorbar = drawColorbar(map)\n\nmap.canvas = d3_selection.select('body')\n  .append('canvas')\n  .attr('width', map.width)\n  .attr('height', map.height)\n\nmap.context = map.canvas.node().getContext('2d')\n\nmap.projection = geoWinkel3().fitExtent(\n  [map.pad, [map.width - 2 * map.pad[0], map.height - map.pad[1]]],\n  sphere\n)\n\nmap.array = makeArray(map)\n\nmap.contours = makeContours(map)\n\nd3_request.json(baseMapUrl, (err, topology) => {\n  if(err) throw err\n\n  var baseMap = topojson.mesh(topology)\n\n  var render = () => {\n    map.context.clearRect(0, 0, map.width, map.height)\n\n    drawPath(map, baseMap, { lineWidth: 1, strokeStyle: blk })\n\n    map.contours.forEach((c) => {\n      drawPath(map, c.feature, { lineWidth: 2, strokeStyle: c.color })\n    })\n\n    drawPath(map, sphere, { lineWidth: 2.5, strokeStyle: blk })\n  }\n\n  render()\n\n  map.canvas\n    .call(makeZoom(map, render))\n    .call(makeHover(map))\n    .on('dblclick.zoom', null)\n\n  map.dropdown.on('click', () => {\n    map.ind = map.dropdown.node().value\n    map.array = makeArray(map)\n    map.contours = makeContours(map)\n    map.canvas.call(makeHover(map))\n    render()\n  })\n})\n\nfunction drawPath(map, d, opts) {\n  var projection = map.projection\n  var path = d3_geo.geoPath(projection, map.context)\n\n  map.context.beginPath()\n  path(d)\n\n  Object.keys(opts).forEach((k) => {\n    map.context[k] = opts[k]\n  })\n\n  map.context.stroke()\n}\n\nfunction drawDropdown(map) {\n  var dropdown = d3_selection.select('body')\n    .append('fieldset')\n    .text(`${data.year} surface temparature anomalies in`)\n    .style('border', 'none')\n    .append('select')\n    .style('margin-left', '10px')\n\n  dropdown.selectAll('option')\n      .data(map.months)\n    .enter()\n      .append('option')\n      .attr('value', (d) => d.ind)\n      .text((d) => d.name)\n\n  dropdown.node().value = String(map.ind)\n\n  return dropdown\n}\n\nfunction drawColorbar(map) {\n  var w = 25\n  var h = 25\n  var tick = 5\n  var offset = 15\n\n  var fullWidth = (map.levels.length + 2) * w\n  var fullHeight = Math.round(h * 2.2)\n\n  var svg = d3_selection.select('body')\n    .append('svg')\n    .style('position', 'absolute')\n    .attr('width', fullWidth)\n    .attr('height', fullHeight)\n    .attr('x', 0)\n    .attr('y', 0)\n\n  var colorbar = svg.append('g')\n\n  colorbar.append('rect')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', fullWidth)\n    .attr('height', fullHeight)\n    .attr('fill', '#fff')\n\n  var items = colorbar.selectAll('.item')\n      .data(map.levels)\n    .enter().append('g')\n      .classed('item', true)\n      .attr('transform', (_, i) => `translate(${i * w + offset},0)`)\n\n  items.append('rect')\n    .attr('x', 0)\n    .attr('y', 0)\n    .attr('width', w)\n    .attr('height', h)\n    .attr('fill', (_, i) => map.colors[i])\n\n  items.append('line')\n    .attr('x1', w / 2)\n    .attr('y1', h)\n    .attr('x2', w / 2)\n    .attr('y2', h + tick)\n    .attr('stroke-width', '1.5')\n    .attr('stroke', 'black')\n\n  items.append('text')\n    .classed('tick', true)\n    .text((d) => d)\n    .attr('x', (d) => w / 2 - (d < 0 ? 1.5 * tick : tick))\n    .attr('y', 2 * h)\n    .style('font-size', map.tickFontSize[0])\n\n  colorbar.append('text')\n    .text('°C')\n    .attr('x', (map.levels.length + 0.75) * w)\n    .attr('y', h - tick)\n\n  return colorbar\n}\n\nfunction makeMonths() {\n  var locale = 'en-ca'\n  var opts = { month: 'long' }\n\n  return data.z.map((_, i) => {\n    var date = new Date(data.year, i, 1)\n    var str = date.toLocaleString(locale, opts)\n\n    return {\n      ind: i,\n      name: str.charAt(0).toUpperCase() + str.substr(1)\n    }\n  })\n}\n\nfunction makeArray(map) {\n  return ndarray(\n    new Float32Array(data.z[map.ind]),\n    [map.lon.size, map.lat.size]\n  )\n}\n\nfunction makeContours(map) {\n  var lon = map.lon\n  var lat = map.lat\n\n  var p2ll = (p) => [\n    lon.start + lon.step * p[0],\n    lat.start + lat.step * p[1]\n  ]\n\n  // don't include the 0-level on map\n  var levels = map.levels.filter((l) => l !== 0)\n\n  var contours = levels.map((l, i) => {\n    var complex = surfaceNets(map.array, l)\n    var cells = complex.cells\n    var positions = complex.positions\n\n    var coordinates = cells.map((c) => {\n      ll0 = p2ll(positions[c[0]])\n      ll1 = p2ll(positions[c[1]])\n\n      return [ll0, ll1]\n    })\n\n    return {\n      feature: {\n        type: 'MultiLineString',\n        coordinates: coordinates\n      },\n      color: map.colors[i]\n    }\n  })\n\n  return contours\n}\n\nfunction makeZoom(map, render) {\n  var projection = map.projection\n  var translate0 = projection.translate()\n  var scale0 = projection.scale()\n\n  var zoom = d3_zoom.zoom()\n    .scaleExtent([1, 100].map((v) => v * scale0))\n\n  map.canvas\n    .call(zoom.translateBy, translate0[0], translate0[1])\n    .call(zoom.scaleBy, scale0)\n\n  var px2ll = (px) => projection.invert(px)\n\n  var mouse = (event) => {\n    var sourceEvent = event.sourceEvent\n\n    return sourceEvent\n      ? [sourceEvent.offsetX, sourceEvent.offsetY]\n      : null\n  }\n\n  var m0, r0, t0, r00, ll0\n\n  function handleStart() {\n    var event = d3_selection.event\n\n    m0 = mouse(event)\n    r0 = projection.rotate()\n    t0 = projection.translate()\n    r00 = r0\n\n    if(m0) {\n      ll0 = px2ll(m0)\n      event.sourceEvent.stopPropagation()\n    }\n  }\n\n  function handleZoom() {\n    map.canvas.style('cursor', 'move')\n\n    var event = d3_selection.event\n    var transform = event.transform\n    var scale = projection.scale()\n    var m1 = mouse(event)\n\n    if(!m1 || !m0) return\n\n    // if cursor in outside sphere on a zoom-only motion,\n    // undo scale transform and skip\n    if(!isInsideSphere(projection, m1) && !isClose(transform.k, scale)) {\n      transform.k = scale\n      return\n    }\n\n    // translate projection along top-down motion\n    // rotate projection along left-right motion\n    projection.scale(transform.k)\n    projection.translate([t0[0], transform.y])\n\n    if(!ll0) {\n      m0 = m1\n      ll0 = px2ll(m0)\n    }\n    else if(px2ll(m1)) {\n      var ll1 = px2ll(m1)\n\n      var r1 = [\n        r00[0] + (ll1[0] - ll0[0]),\n        r0[1]\n      ]\n\n      projection.rotate(r1)\n      r00 = r1\n    }\n\n    render()\n  }\n\n  function handleEnd() {\n    map.canvas.style('cursor', 'auto')\n  }\n\n  zoom\n    .on('start', handleStart)\n    .on('zoom', handleZoom)\n    .on('end', handleEnd)\n\n  return zoom\n}\n\nfunction makeHover(map) {\n  var array = map.array\n  var lon = map.lon\n  var lat = map.lat\n  var levels = map.levels\n  var projection = map.projection\n\n  var mouse = (event) => [event.offsetX, event.offsetY]\n  var clamp = (v, bnds) => Math.max(bnds[0], Math.min(v, bnds[1]))\n\n  var px2ll = (px) => projection.invert(px)\n\n  var ll2ij = (ll) => [\n    Math.round((ll[0] - lon.start) / lon.step),\n    Math.round((ll[1] - lat.start) / lat.step)\n  ]\n\n  var val2lev = (val) => clamp(\n    (val > 0 ? Math.floor(val) : Math.ceil(val)) - levels[0],\n    [0, levels.length - 1]\n  )\n\n  return (canvas) => {\n\n    canvas.on('mousemove', () => {\n      var px = mouse(d3_selection.event)\n      var ll = px2ll(px)\n      var ij = ll2ij(ll)\n      var val = array.get(ij[0], ij[1])\n\n      var lev = isInsideSphere(projection, px)\n        ? val2lev(val)\n        : null\n\n      map.colorbar.selectAll('.tick')\n        .style('font-weight', (_, i) => i === lev ? 'bold' : null)\n        .style('font-size', (_, i) => i === lev ? map.tickFontSize[1] : map.tickFontSize[0])\n    })\n\n    canvas.on('mouseout', () => {\n      map.colorbar.selectAll('.tick')\n        .style('font-weight', null)\n        .style('font-size', map.tickFontSize[0])\n    })\n  }\n}\n\n// projection:\n//   maps unbounded ll domain to bounded (by sphere size) px range\n// projection.invert:\n//   maps bounded (by canvas size) px domain to bounded (-180,180) ll range\n//\n// To verify that cursor is inside sphere, check that:\n//   mouse = projection(projection.invert(mouse))\nfunction isInsideSphere(projection, px) {\n  var ll = projection.invert(px)\n  var lat = ll[1]\n  var pxp = projection(ll)\n\n  return (\n    lat <= 90 &&\n    lat >= -90 &&\n    isClose(px[0], pxp[0]) &&\n    isClose(px[1], pxp[1])\n  )\n}\n\nfunction isClose(a, b) {\n  return Math.abs(a - b) < 1\n}\n"},{"filename":"preprocess.jl","body":"import NetCDF\nimport JSON\n\ninfile = \"data.nc\"\noutfile = \"data.json\"\nyear = 2016\nclimate = 1986:2015\n\nfunction hours2datetimes(hours)\n    ms_in_hour = 60 * 60 * 1000\n    base_date = DateTime(1800, 1, 1)\n    base_ms = Dates.datetime2epochms(base_date)\n\n    return [Dates.epochms2datetime(h * ms_in_hour + base_ms) for h in hours]\nend\n\nfunction find_inds(datetimes, target)\n    find(d -> Dates.year(d) in target, datetimes)\nend\n\nfunction reshape_coords(lon, lat, air)\n\n    # reverse lat from [90,-90] to [-90, 90]\n    reverse!(lat)\n    air = flipdim(air, 2)\n\n    # shift lon to from [0,360] to [-180,180]\n    shape = size(air)\n    lon180 = find(l -> l == 180, lon)[1]\n    shift = lon180 - 2\n\n    # shift air lon dim accordingly\n    lon = circshift(map(l -> l > 180 ? l - 360 : l, lon), shift)\n    air = circshift(air, (shift,0,0))\n\n    return lon, lat, air\nend\n\nfunction calc_air_climate(air, inds_climate)\n    shape1 = size(air)\n    shape2 = shape1[1], shape1[2], 12, length(climate)\n\n    return squeeze(mean(reshape(air[:,:,inds_climate], shape2), 4), 4)\nend\n\nfunction calc_air_diff(air, inds_year, inds_climate)\n    air_climate = calc_air_climate(air, inds_climate)\n\n    return air[:,:,inds_year] .- air_climate[:,:,1:length(inds_year)]\nend\n\n# lon / lat boxcar filter\n#\n# Adapted from\n# http://julialang.org/blog/2016/02/iteration\nfunction smooth(A::AbstractArray)\n    B = similar(A)\n\n    for m in 1:size(A)[3]\n        a = A[:,:,m]\n        R = CartesianRange(size(a))\n        I1, Iend = first(R), last(R)\n        for I in R\n            n, s = 0, zero(eltype(B))\n            for J in CartesianRange(max(I1, I-I1), min(Iend, I+I1))\n                s += a[J]\n                n += 1\n            end\n            B[I[1],I[2],m] = s/n\n        end\n    end\n\n    return B\nend\n\nfunction format_z(z)\n\n    # smooth\n    z = smooth(z)\n\n    # add two lon columns to draw contour pass anti-meridian\n    shape = size(z)\n    z = vcat(z, reshape(z[1:2,:,:], (2,shape[2],shape[3])))\n\n    # transpose and merge lon/lat\n    shape = size(z)\n    z = reshape(permutedims(z, [2,1,3]), (shape[1]*shape[2],shape[3]))\n\n    # convert to 16-bit float for smaller bundle\n    f(x) = convert(Float16, x)\n    z = f.(z)\n\n    return z\nend\n\nfunction get_meta(v)\n    v[1], unique(diff(v))[1], length(v)\nend\n\nfunction format_output(z, lon, lat)\n    Dict(\n        \"z\" => format_z(z),\n        \"year\" => year,\n        \"lon\" => get_meta(lon),\n        \"lat\" => get_meta(lat)\n    )\nend\n\n# Use NetCDF.ncinfo(infile) for more info\n#\n# We are assuming ordered data\n#\n# \"time\" is in hours after 1800-01-01\n# \"air\" is in degree Celsius lon x lat x time\nfunction main()\n    hours = NetCDF.ncread(infile, \"time\")\n    lon = NetCDF.ncread(infile, \"lon\")\n    lat = NetCDF.ncread(infile, \"lat\")\n    air = NetCDF.ncread(infile, \"air\")\n\n    datetimes = hours2datetimes(hours)\n    inds_year = find_inds(datetimes, year)\n    inds_climate = find_inds(datetimes, climate)\n\n    lon, lat, air = reshape_coords(lon, lat, air)\n    air_diff = calc_air_diff(air, inds_year, inds_climate)\n\n    open(outfile, \"w\") do f\n        JSON.print(f, format_output(air_diff, lon, lat))\n    end\nend\n\nmain()\n"},{"filename":"makefile","body":"url = \"ftp://ftp.cdc.noaa.gov/Datasets/ncep.reanalysis.derived/surface/air.mon.mean.nc\"\nnode_bin = $(shell pwd)/node_modules/.bin/\n\nexport PATH := $(node_bin):$(PATH)\n\nall : deps index.html\n\ndeps : julia_deps node_modules\n\njulia_deps :\n\tjulia -e 'Pkg.add(\"NetCDF\"); Pkg.add(\"JSON\")'\n\nnode_modules : \n\tnpm install\n\ndata.nc :\n\twget $(url) -O data.nc\n\ndata.json : data.nc \n\tjulia preprocess.jl\n\nprojection.js :\n\td3-geo-projection-picker winkel3 > projection.js\n\nindex.html : data.json projection.js\n\tbrowserify -t es2020 index.js | uglifyjs | indexhtmlify > index.html\n\nclean :\n\trm -f data.nc data.json projection.js index.html\n\n.PHONY : clean deps all\n"},{"filename":"package.json","body":"{\n  \"name\": \"surface-temperature-anomalies-2016\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Interactive contour maps of surface temperature anomalies in 2016\",\n  \"main\": \"index.js\",\n  \"author\": \"Étienne Tétreault-Pinard\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"d3-geo\": \"^1.3.1\",\n    \"d3-request\": \"^1.0.2\",\n    \"d3-selection\": \"^1.0.2\",\n    \"d3-zoom\": \"^1.0.3\",\n    \"ndarray\": \"^1.0.18\",\n    \"surface-nets\": \"^1.0.2\",\n    \"topojson-client\": \"^2.1.0\"\n  },\n  \"devDependencies\": {\n    \"browserify\": \"^13.1.1\",\n    \"d3-geo-projection-picker\": \"^3.0.0\",\n    \"es2020\": \"^1.1.9\",\n    \"indexhtmlify\": \"^1.3.1\",\n    \"uglify-js\": \"^2.7.4\"\n  }\n}\n"},{"filename":".gitignore","body":"node_modules\nnpm-debug.log\n\ndata.nc\ndata.json\nprojection.js\n"}]}